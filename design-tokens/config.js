/**
 * Style Dictionary configuration for Luminous design tokens.
 *
 * This configuration generates platform-specific token outputs from
 * the single source of truth tokens.json file.
 */

const StyleDictionary = require('style-dictionary');

// Custom format for CSS variables
StyleDictionary.registerFormat({
  name: 'css/luminous-variables',
  formatter: function({ dictionary, file }) {
    return `/**
 * Luminous Design Tokens
 * Generated by Style Dictionary
 * Do not edit directly
 */

:root {
${dictionary.allProperties.map(prop => {
  const comment = prop.comment ? ` /* ${prop.comment} */` : '';
  return `  --${prop.name}: ${prop.value};${comment}`;
}).join('\n')}
}
`;
  }
});

// Custom format for Swift
StyleDictionary.registerFormat({
  name: 'swift/luminous-extensions',
  formatter: function({ dictionary }) {
    const colorTokens = dictionary.allProperties.filter(p => p.attributes.category === 'color');
    const spacingTokens = dictionary.allProperties.filter(p => p.attributes.category === 'spacing');
    const radiusTokens = dictionary.allProperties.filter(p => p.attributes.category === 'radius');
    const touchTokens = dictionary.allProperties.filter(p => p.attributes.category === 'touch');
    const fontSizeTokens = dictionary.allProperties.filter(p =>
      p.attributes.category === 'font' && p.attributes.type === 'size'
    );

    function formatColorValue(value) {
      const hex = value.replace('#', '');
      return `Color(hex: "${hex}")`;
    }

    function formatDimensionValue(value) {
      const num = parseFloat(value);
      return `${num}`;
    }

    return `//
// DesignTokens.swift
// Luminous Design System
//
// Generated by Style Dictionary - Do not edit directly
//

import SwiftUI

public extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

public enum DesignTokens {
    public enum Colors {
${colorTokens.map(token => {
  const path = token.path.slice(1); // Remove 'color' prefix
  const name = path.join('_').replace(/-/g, '_');
  return `        public static let ${name} = ${formatColorValue(token.value)}`;
}).join('\n')}
    }

    public enum Spacing {
${spacingTokens.map(token => {
  const name = '_' + token.path[1];
  return `        public static let ${name}: CGFloat = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }

    public enum Radius {
${radiusTokens.map(token => {
  const name = token.path[1];
  return `        public static let ${name}: CGFloat = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }

    public enum Touch {
${touchTokens.map(token => {
  const name = token.path[1];
  return `        public static let ${name}: CGFloat = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }

    public enum FontSize {
${fontSizeTokens.map(token => {
  const name = token.path[2].replace(/-/g, '_');
  return `        public static let ${name}: CGFloat = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }
}
`;
  }
});

// Custom format for Kotlin/Compose
StyleDictionary.registerFormat({
  name: 'compose/luminous-object',
  formatter: function({ dictionary }) {
    const colorTokens = dictionary.allProperties.filter(p => p.attributes.category === 'color');
    const spacingTokens = dictionary.allProperties.filter(p => p.attributes.category === 'spacing');
    const radiusTokens = dictionary.allProperties.filter(p => p.attributes.category === 'radius');
    const touchTokens = dictionary.allProperties.filter(p => p.attributes.category === 'touch');

    function formatColorValue(value) {
      const hex = value.replace('#', '');
      return `Color(0xFF${hex.toUpperCase()})`;
    }

    function formatDimensionValue(value) {
      const num = parseFloat(value);
      return `${num}.dp`;
    }

    return `/**
 * DesignTokens.kt
 * Luminous Design System
 *
 * Generated by Style Dictionary - Do not edit directly
 */

package com.luminous.design

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

object DesignTokens {
    object Colors {
${colorTokens.map(token => {
  const path = token.path.slice(1);
  const name = path.map((p, i) => i === 0 ? p : p.charAt(0).toUpperCase() + p.slice(1)).join('').replace(/-/g, '');
  return `        val ${name} = ${formatColorValue(token.value)}`;
}).join('\n')}
    }

    object Spacing {
${spacingTokens.map(token => {
  const name = '_' + token.path[1];
  return `        val ${name} = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }

    object Radius {
${radiusTokens.map(token => {
  const name = token.path[1];
  return `        val ${name} = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }

    object Touch {
${touchTokens.map(token => {
  const name = token.path[1];
  return `        val ${name} = ${formatDimensionValue(token.value)}`;
}).join('\n')}
    }
}
`;
  }
});

// Custom format for Tailwind config
StyleDictionary.registerFormat({
  name: 'javascript/luminous-tailwind',
  formatter: function({ dictionary }) {
    const colors = {};
    const spacing = {};
    const borderRadius = {};

    dictionary.allProperties.forEach(token => {
      if (token.attributes.category === 'color') {
        const [, group, ...rest] = token.path;
        if (!colors[group]) colors[group] = {};
        if (rest.length === 0) {
          colors[group] = `var(--${token.name})`;
        } else {
          colors[group][rest.join('-')] = `var(--${token.name})`;
        }
      } else if (token.attributes.category === 'spacing') {
        spacing[token.path[1]] = `var(--${token.name})`;
      } else if (token.attributes.category === 'radius') {
        borderRadius[token.path[1]] = `var(--${token.name})`;
      }
    });

    return `/**
 * Tailwind CSS Design Tokens Extension
 * Luminous Design System
 *
 * Generated by Style Dictionary - Do not edit directly
 *
 * Import in tailwind.config.js:
 * const tokens = require('./design-tokens/build/tailwind/tokens.js');
 * module.exports = { theme: { extend: tokens } }
 */

module.exports = ${JSON.stringify({ colors, spacing, borderRadius }, null, 2)};
`;
  }
});

module.exports = {
  source: ['tokens.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'build/css/',
      files: [{
        destination: 'tokens.css',
        format: 'css/luminous-variables',
        options: {
          outputReferences: true
        }
      }]
    },
    scss: {
      transformGroup: 'scss',
      buildPath: 'build/scss/',
      files: [{
        destination: '_tokens.scss',
        format: 'scss/variables'
      }]
    },
    swift: {
      transformGroup: 'ios-swift',
      buildPath: 'build/swift/',
      files: [{
        destination: 'DesignTokens.swift',
        format: 'swift/luminous-extensions',
        className: 'DesignTokens'
      }]
    },
    kotlin: {
      transformGroup: 'compose',
      buildPath: 'build/kotlin/',
      files: [{
        destination: 'DesignTokens.kt',
        format: 'compose/luminous-object',
        packageName: 'com.luminous.design'
      }]
    },
    tailwind: {
      transformGroup: 'js',
      buildPath: 'build/tailwind/',
      files: [{
        destination: 'tokens.js',
        format: 'javascript/luminous-tailwind'
      }]
    },
    json: {
      transformGroup: 'js',
      buildPath: 'build/json/',
      files: [{
        destination: 'tokens.json',
        format: 'json/nested'
      }]
    }
  }
};
